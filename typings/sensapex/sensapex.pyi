"""
This type stub file was generated by pyright.
"""

import platform
import subprocess
import sys
import threading
from ctypes import Structure

if sys.platform == "win32":
    DUMPCAP = ...
else:
    DUMPCAP = ...
SOCKET = ...
if sys.platform == "win32" and platform.architecture()[0] == "64bit":
    SOCKET = ...
LIBUM_MAX_MANIPULATORS = ...
LIBUM_MAX_LOG_LINE_LENGTH = ...
LIBUM_DEF_TIMEOUT = ...
LIBUM_DEF_BCAST_ADDRESS = ...
LIBUM_DEVICE_SUBNET = ...
LIBUM_DEF_GROUP = ...
LIBUM_MAX_MESSAGE_SIZE = ...
LIBUM_ARG_UNDEF = ...
X_AXIS = ...
Y_AXIS = ...
Z_AXIS = ...
D_AXIS = ...
LIBUM_NO_ERROR = ...
LIBUM_OS_ERROR = ...
LIBUM_NOT_OPEN = ...
LIBUM_TIMEOUT = ...
LIBUM_INVALID_ARG = ...
LIBUM_INVALID_DEV = ...
LIBUM_INVALID_RESP = ...
class sockaddr_in(Structure):
    _fields_ = ...


log_func_ptr = ...
class um_positions(Structure):
    _fields_ = ...


class um_state(Structure):
    _fields_ = ...


class MoveRequest:
    """Class for coordinating and tracking moves.
    """
    max_attempts = ...
    def __init__(self, ump, dev, dest, speed, simultaneous=..., linear=..., max_acceleration=..., retry_threshold=...) -> None:
        ...

    def interrupt(self, reason): # -> None:
        ...

    def finish(self): # -> None:
        ...

    def start(self): # -> None:
        ...

    def is_in_progress(self):
        ...

    def can_retry(self): # -> bool:
        ...

    def is_close_enough(self): # -> numpy.bool[builtins.bool]:
        ...

    def has_more_calls_to_make(self): # -> bool:
        ...

    def make_next_call(self): # -> None:
        ...



class UMError(Exception):
    def __init__(self, msg, errno, oserrno) -> None:
        ...



_timer_offset = ...
def timer(): # -> float:
    ...

class UMP:
    """Wrapper for the Sensapex uMp API.

    All calls except get_ump are thread-safe.
    """
    _pcap_proc: subprocess.Popen | None
    _last_move: dict[int, MoveRequest]
    _lib = ...
    _lib_path = ...
    _single = ...
    _um_state = ...
    _debug_at_cls = ...
    _default_group = ...
    _default_address = ...
    @classmethod
    def set_library_path(cls, path: str): # -> None:
        ...

    @classmethod
    def set_default_address(cls, address): # -> None:
        ...

    @classmethod
    def set_default_group(cls, group): # -> None:
        ...

    @classmethod
    def get_lib(cls): # -> WinDLL | CDLL:
        ...

    @classmethod
    def load_lib(cls): # -> WinDLL | CDLL:
        ...

    @classmethod
    def get_um_state_class(cls): # -> type[um_state]:
        ...

    @classmethod
    def get_ump(cls, address=..., group=..., start_poller=...) -> UMP:
        """Return a singleton UM instance.
        """

    def __init__(self, address, group, start_poller=...) -> None:
        ...

    def set_timeout(self, value: int): # -> None:
        ...

    @classmethod
    def set_debug_mode(cls, enabled: bool) -> None:
        ...

    def create_debug_archive(self) -> str:
        """Zip up the debug log and all pcap files for distribution to Sensapex."""

    def get_device(self, dev_id, *args, **kwargs) -> SensapexDevice:
        """

        Returns
        -------
        SensapexDevice
        """

    def sdk_version(self): # -> Any:
        """Return version of UM SDK.
        """

    def list_devices(self, max_id=...): # -> list[Any]:
        """Return a list of all connected device IDs.
        """

    def axis_count(self, dev): # -> Any | Literal[4]:
        ...

    def set_axis_count(self, dev, count): # -> None:
        ...

    def call(self, fn, *args, retries: int | None = ...): # -> Any:
        ...

    def set_max_acceleration(self, dev, max_acc): # -> None:
        ...

    def open(self, address, group): # -> None:
        """Open the UM devices at the given address.

        The default address "169.254.255.255" should suffice in most situations.
        """

    def close(self): # -> None:
        """Close the UM device.
        """

    @staticmethod
    def is_positionable(dev_id):
        ...

    def get_pos(self, dev, timeout=...): # -> list[float | int]:
        """Return the absolute position of the specified device (in um).

        If *timeout* == 0, then the position is returned directly from cache
        and not queried from the device.
        """

    def goto_pos(self, dev, dest, speed, simultaneous=..., linear=..., max_acceleration=...): # -> MoveRequest:
        """Request the specified device to move to an absolute position (in um).

        Parameters
        ----------
        dev : int
            ID of device to move
        dest : array-like
            X,Y,Z,W coordinates to move to. Values may be NaN or omitted to leave
            the axis unaffected.
        speed : float
            Manipulator speed in um/sec
        simultaneous: bool
            If True, then all axes begin moving at the same time
        linear : bool
            If True, then axis speeds are scaled to produce more linear movement, requires simultaneous
        max_acceleration : int
            Maximum acceleration in um/s^2

        Returns
        -------
        move_request : MoveRequest
            Object that can be used to retrieve the status of this move at a later time.
        """

    def is_busy(self, dev): # -> Any | Literal[False]:
        """Return True if the specified device is currently moving.

        Note: this should not be used to determine whether a move has completed;
        use MoveRequest.finished or .finished_event as returned from goto_pos().
        """

    def stop(self, dev): # -> None:
        """Stop the specified manipulator.
        """

    def set_pressure(self, dev, channel, value): # -> Any:
        ...

    def get_pressure(self, dev, channel): # -> float:
        ...

    def measure_pressure(self, dev, channel): # -> float:
        ...

    def set_valve(self, dev, channel, value): # -> Any:
        ...

    def get_valve(self, dev, channel): # -> Any:
        ...

    def set_custom_slow_speed(self, dev, enabled): # -> Any:
        ...

    def get_custom_slow_speed(self, dev): # -> Any:
        ...

    def get_um_param(self, dev, param): # -> c_int:
        ...

    def set_um_param(self, dev, param, value): # -> Any:
        ...

    def run_um_cmd(self, dev_id, cmd, *args): # -> None:
        ...

    def restart_device(self, dev_id): # -> None:
        ...

    def set_device_group(self, dev_id, group): # -> None:
        ...

    def calibrate_zero_position(self, dev): # -> None:
        ...

    def calibrate_load(self, dev): # -> None:
        ...

    def calibrate_pressure(self, dev, channel, delay): # -> None:
        ...

    def led_control(self, dev, off): # -> None:
        ...

    def get_soft_start_state(self, dev): # -> Any:
        ...

    def set_soft_start_state(self, dev, enabled): # -> Any:
        ...

    def get_soft_start_value(self, dev): # -> c_int:
        ...

    def set_soft_start_value(self, dev, value): # -> Any:
        ...

    def set_retry_threshold(self, threshold): # -> None:
        """
        If we miss any axis by too much, try again.

        Parameters
        ----------
        threshold : float
            Maximum allowable error in Âµm.
        """

    def recv_all(self): # -> None:
        """Receive all queued position/status update packets and update any pending moves.
        """

    def track_device_ids(self, *dev_ids): # -> None:
        ...

    def get_firmware_version(self, dev_id): # -> tuple[Any, ...]:
        """Return the firmware version installed on a device.
        """

    def ping_device(self, dev_id): # -> None:
        """Ping a device.

        Returns after ping is received, or raises an exception on timeout.
        """



class SensapexDevice:
    """UM wrapper for accessing a single sensapex device.

    Example:

        dev = SensapexDevice(1)  # get handle to manipulator 1
        pos = dev.get_pos()
        pos[0] += 10000  # add 10 um to x axis
        dev.goto_pos(pos, speed=10)
    """
    def __init__(self, dev_id: int, callback=..., n_axes=..., max_acceleration=..., is_stage=...) -> None:
        ...

    def set_n_axes(self, n_axes): # -> None:
        ...

    def n_axes(self): # -> Any | Literal[4]:
        ...

    def set_max_acceleration(self, max_acceleration): # -> None:
        ...

    def add_callback(self, callback): # -> None:
        ...

    def get_pos(self, timeout=...): # -> list[float | int]:
        ...

    def goto_pos(self, pos, speed, simultaneous=..., linear=..., max_acceleration=...): # -> MoveRequest:
        ...

    @property
    def is_stage(self): # -> Literal[False]:
        ...

    def is_busy(self): # -> Any | Literal[False]:
        ...

    def stop(self): # -> None:
        ...

    def set_pressure(self, channel, value): # -> Any:
        """
        Parameters
        ----------
        channel : int
            channel number
        value : float
            pressure in kPa
        """

    def get_pressure(self, channel): # -> float:
        """
        Returns
        -------
        float
            expected pressure in kPa
        """

    def measure_pressure(self, channel): # -> float:
        """
        Returns
        -------
        float
            actual pressure in kPa
        """

    def set_valve(self, channel, value): # -> Any:
        ...

    def get_valve(self, channel): # -> Any:
        ...

    def set_lens_position(self, pos, lift=..., dip=...): # -> Any:
        ...

    def get_lens_position(self): # -> Any:
        ...

    def set_custom_slow_speed(self, enabled): # -> Any:
        ...

    def calibrate_zero_position(self): # -> None:
        ...

    def calibrate_load(self): # -> None:
        ...

    def calibrate_pressure(self, channel, delay=...): # -> None:
        ...

    def set_led_enabled(self, on: bool): # -> None:
        ...

    def get_soft_start_state(self): # -> Any:
        ...

    def set_soft_start_state(self, enabled): # -> Any:
        ...

    def get_soft_start_value(self): # -> int:
        ...

    def set_soft_start_value(self, value): # -> Any:
        ...



class PollThread(threading.Thread):
    """Thread to poll for all manipulator position changes.

    Running this thread ensures that calling get_pos will always return the most recent
    values available.

    An optional callback function is called periodically with a list of
    device IDs from which position updates have been received.
    """
    def __init__(self, ump, interval=...) -> None:
        ...

    def start(self): # -> None:
        ...

    def stop(self): # -> None:
        ...

    def add_callback(self, dev_id, callback): # -> None:
        ...

    def remove_callback(self, dev_id, callback): # -> None:
        ...

    def run(self): # -> None:
        ...



